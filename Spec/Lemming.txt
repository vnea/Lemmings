Service: Lemming

Types: bool, int, enum Direction{LEFT, RIGHT}, enum Behaviour{WALKER, FALLER, DIGGER, BUILDER, STOPPER, BASHER}, enum State{BASIC, CLIMBER, FLOATER, BOMBER}

Observators: 
			 const num: [Lemming] -> int
			 direction: [Lemming] -> Direction
			 behaviour: [Lemming] -> Behaviour
			 state: [Lemming] -> State
			 hPos: [Lemming] -> int
			 wPos: [Lemming] -> int
			 dead: [Lemming] -> bool
			 gameEngine: [Lemming] -> GameEng

Constructors:
			 init: int * int * int * GameEng -> [Lemming]
		 	       pre init(num, h, w, G) require num ≥ 0 ^ h ≥ 2 ^ w ≥ 1 
Operators:
			 step: [Lemming] -> [Lemming]
			 
Observations:
			 [invariants] 
			 	   GameEng::obstacle(gameEngine(L),hPos(L)-1,wPos(L)) = false
			 [init]
			 		num(init(num,h,w,G)) = num
			 		hPos(init(num,h,w,G)) = h
			 		wPos(init(num),h,w,G)) = w
			 		direction(init(num,h,w,G)) = Direction::RIGHT
			 		behaviour(init(num,h,w,G)) = Behaviour::FALLER
			 		state(init(num,h,w,G)) = State::BASIC
			 		dead(init(num,h,w,G)) = false
			 [step]
			 		if behaviour(L)=Behaviour::WALKER then:
			 			if direction(L)=Direction::RIGHT then:
			 				if GameEng::obstacle(gameEngine(L),hPos(L)+1,wPos(L))=false then:
			 						behaviour(step(L)) = Behaviour::FALLER
			 				else if GameEng::obstacle(gameEngine(L),hPos(L)-1,wPos(L)+1) then
			 						direction(step(L)) = Direction::LEFT
			 				else if GameEng::obstacle(gameEngine(L),hPos(L),wPos(L)+1) then:
			 					if GameEng::obstacle(gameEngine(L),hPos(L)-2,wPos(L)+1)) then:
			 							direction(step(L)) = Direction::LEFT
			 					else: 
			 							hPos(step(L)) = hPos(L)-1 ^ wPos(step(L)) = wPos(L)+1
			 				else:
			 						wPos(step(L)) = wPos(L)+1
			 			else: 
			 				if GameEng::obstacle(gameEngine(L),hPos(L)+1,wPos(L))=false then:
			 						behaviour(step(L)) = Behaviour::FALLER
			 				else if GameEng::obstacle(gameEngine(L),hPos(L)-1,wPos(L)-1) then
			 						direction(step(L)) = Direction::RIGHT
			 				else if GameEng::obstacle(gameEngine(L),hPos(L),wPos(L)-1) then:
			 					if GameEng::obstacle(gameEngine(L),hPos(L)-2,wPos(L)-1)) then:
			 							direction(step(L)) = Direction::LEFT
			 					else: 
			 							hPos(step(L)) = hPos(L)-1 ^ wPos(step(L)) = wPos(L)-1
			 				else:
			 						wPos(step(L)) = wPos(L)-1
			 			
			 		else if behaviour(L)=Behaviour::FALLER then:
			 			if GameEng::obstacle(gameEngine(L),hPos(L)+1,wPos(L))=false then:
			 					hPos(step(L)) = hPos(L)+1
			 			else: 
			 				if direction(step(L)) = Direction::RIGHT then:
				 				if ∀i, -1<i<7 GameEng::obstacle(gameEngine(L),hPos(L)-i,wPos(L)-1)=false then:
				 						dead(step(l)) = true
				 			else if direction(step(L)) = Direction::LEFT then:
				 				if ∀i, -1<i<7 GameEng::obstacle(gameEngine(L),hPos(L)-i,wPos(L)+1)=false then:
				 						dead(step(l)) = true
			 				
			 				if dead(step(l))==false then:
			 					behaviour(step(L)) = Behaviour::WALKER
			 					
			 			
		 	