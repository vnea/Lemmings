Service: GameEng

Types: bool, int

Observators:
			 score: [GameEng] -> int
			 	   pre score(G) require gameOver(G)
			 turn: [GameEng] -> int
			 obstacle: [GameEng] * int * int -> bool
			 const sizeColony: [GameEng] -> int
			 nbLemmingsDead: [GameEng] -> int
			 nbLemmingsSaved: [GameEng] -> int 
			 nbLemmingsActive: [GameEng] -> int
			 nbLemmingsCreated: [GameEng] -> int
			 lemming: [GameEng] * int -> Lemming
			 	   pre lemming(G,num) require active(G,num)
			 active: [GameEng] * int -> bool
			 numLemmingsActive: [GameEng] -> Set<int>
			 const spawnSpeed: [GameEng] -> int
			 gameOver:[GameEng] -> bool
			 level: [GameEng] -> Level
			 
Constructors: 
			 init: int * int * Level -> [GameEng]
			 	   pre init(sizeC,spawnS,L) require sizeC>0 ^ spawnS>0
Operators:
			 newLemming: [GameEng] * int -> [GameEng]
			 	   pre newLemming(G,num) require active(G,num)=false 
			 	   								  ^ nbLemmingsCreated(G) < sizeColony(G)
			 	   								  ^ nbLemmingsCreated(G)*spawnSpeed(G) = turn(G)
			 	   								  ^ gameOver(G)=false
			 callStepLemmings: [GameEng] -> [GameEng]
			       pre callStepLemmings(G) require gameOver(G)=false
			 checkSaved: [GameEng] -> [GameEng]
			       pre checkSaved(G) require gameOver(G)=false
			 checkDead: [GameEng] -> [GameEng]
			       pre checkDead(G) require gameOver(G)=false
			 checkWin: [GameEng] -> [GameEng]
			       pre checkWin(G) require gameOver(G)=false
			 
Observations: 
			 [invariants]
			 		obstacle(G,h,w) = ((Level::nature(level(G),h,w) = Nature::DIRT) or 
			 							(Level::nature(level(G),h,w) = Nature::METAL)) //minimisation
			 		active(G,num) = num ∈ numLemmingsActive(G) //minimisation
			 		gameOver(G) = (nbLemmingsSaved(G) + nbLemmingsDead(G) = sizeColony(G)) //minimisation
			 		nbLemmingsActive(G) = card(numLemmingsActive(G)) //minimisation
			 		nbLemmingsCreated(G) = nbLemmingsDead(G) + nbLemmingsSaved(G) + nbLemmingsActive(G)  //minimisation 
			 		sizeColony(G) ≥ nbLemmingsCreated(G)
			 		nbLemmingsActive(G) ≥ 0
			 		nbLemmingsDead(G)≥ 0
			 		nbLemmingsSaved(G) ≥ 0
			 		nbLemmingsCreated(G) ≥ 0
			 [init]
			 		turn(init(sizeC,spawnS,L)) = 0
			 		sizeColony(init(sizeC,spawnS,L)) = sizeC
			 		nbLemmingsDead(init(sizeC,spawnS,L)) = 0
			 		nbLemmingsSaved(init(sizeC,spawnS,L)) = 0
			 		card(numLemmingsActive(init(sizeC,spawnS,L))) = 0
			 		spawnSpeed(init(sizeC,spawnS,L)) = spawnS
			 		level(init(sizeC,spawnS,L)) = L	
			 [callStepLemmings]
			        turn(callStepLemmings(G)) = turn(G) + 1	
			 [newLemming]
			 		numLemmingsActive(newLemming(G,num)) = numLemmingsActive U {num}
			 		lemming(newLemming(G,num),num) = Lemming::init(num,G)
			 		∀ n ∈ numLemmingsActive(G) lemming(newLemming(G,num),n) = lemming(G,n)
			 		Lemming::hPos(lemming(newLemming(G,num),num) = Level::hEntrance(level(G))
			 		Lemming::wPos(lemming(newLemming(G,num),num) = Level::wEntrance(level(G))
			 [checkSaved]
			 		∀ num ∈ numLemmingsActive(G) if Lemming::hPos(lemming(G),num) = Level::hExit(level(checkSaved(G))) ^
			 		                                Lemming::wPos(lemming(G),num) = Level::wExit(level(checkSaved(G))) then:
			 		    numLemmingsActive(checkSaved(G)) = numLemmingsActive(G) \ {num}
			 		nbLemmingSaved(checkSaved(G)) = nbLemmingsCreated(checkSaved(G)) - (nbLemmingsActive(checkSaved(G))	+ nbLemmingsDead(checkSaved(G)))	
			 [checkDead]
			 		∀ num ∈ numLemmingsActive(G) if Lemming::dead(lemming(G,num)) then:
                        numLemmingsActive(checkDead(G)) = numLemmingsActive(G) \{num}
                    nbLemmingsDead(checkDead(G)) = nbLemmingsCreated(checkDead(G)) - (nbLemmingsActive(checkDead(G)) + nbLemmingsSaved(checkDead(G)))
			 [checkWin]
			 		if gameOver(G) then:
			 			  score(checkWin(G)) = (nbLemmingsSaved(G)/turn(G)) * 100

